#!/usr/bin/perl

# создаем нужные файлы из БД rkn

use strict;
use warnings;
use Config::Simple;
use DBI;
use File::Basename;
use URI;
use Net::Nslookup;
use POSIX;
use Digest::MD5;
use Log::Log4perl;

use utf8;
my $dir = File::Basename::dirname($0);

my $Config = {};
Config::Simple->import_from($dir.'/rkn.conf', $Config) or die "Can't open ".$dir."/rkn.conf for reading!\n";
Log::Log4perl::init( $dir."/rkn_log.conf" );

my $logger=Log::Log4perl->get_logger();

my $db_host = $Config->{'DB.host'} || die "DB.host not defined.";
my $db_user = $Config->{'DB.user'} || die "DB.user not defined.";
my $db_pass = $Config->{'DB.password'} || die "DB.password not defined.";
my $db_name = $Config->{'DB.name'} || die "DB.name not defined.";

my @resolvers = $Config->{'NS.resolvers'} || ();

# пути к генерируемым файлам:
my $bgpd_file = $Config->{'BGP.quagga_config'} || "";
my $domains_file = $Config->{'APP.domains'} || "";
my $urls_file = $Config->{'APP.urls'} || "";
my $ssls_file = $Config->{'APP.ssls'} || "";
my $hosts_file = $Config->{'APP.hosts'} || "";

my $bgp_as = $Config->{'BGP.our_as'} || "";
my $bgp_router_id = $Config->{'BGP.router_id'} || "";
my $bgp_neighbor = $Config->{'BGP.neighbor'} || "";
my $bgp_remote_as = $Config->{'BGP.remote_as'} || "";

my $dbh = DBI->connect("DBI:mysql:database=".$db_name.";host=".$db_host,$db_user,$db_pass,{mysql_enable_utf8 => 1}) or die DBI->errstr;
$dbh->do("set names utf8");


my $domains=0;
my $only_ip=0;
my $urls=0;
my $https=0;
my $total_entry=0;
my %ip_s;

my $domains_file_hash_old=get_md5_sum($domains_file);
my $urls_file_hash_old=get_md5_sum($urls_file);
my $ssl_host_file_hash_old=get_md5_sum($ssls_file);
my $net_file_hash_old=get_md5_sum($bgpd_file);

open (my $DOMAINS_FILE, ">",$domains_file) or die "Could not open file '$domains_file' $!";
open (my $URLS_FILE, ">",$urls_file) or die "Could not open file '$urls_file' $!";
open (my $SSL_HOST_FILE, ">",$ssls_file) or die "Could not open file '$ssls_file' $!";
open (my $NET_FILE, ">",$bgpd_file) or die "Could not open file '$bgpd_file' $!";
open (my $HOSTS_FILE, ">",$hosts_file) or die "Could not open file '$hosts_file' $!";

my $cur_time=strftime "%F %T", localtime $^T;



print $NET_FILE "! Generated by super-puper script\n!\n!\nrouter bgp $bgp_as\n bgp router-id $bgp_router_id\n neighbor $bgp_neighbor remote-as $bgp_remote_as\n";

my %ssl_hosts;

my $sth = $dbh->prepare("SELECT * FROM zap2_domains");
$sth->execute;
while (my $ips = $sth->fetchrow_hashref())
{
	print $DOMAINS_FILE $ips->{domain}."\n";
}
$sth->finish();

$sth = $dbh->prepare("SELECT * FROM zap2_urls");
$sth->execute;
while (my $ips = $sth->fetchrow_hashref())
{
	my $url2=$ips->{url};
	my $only_hosts=0;
	if($url2 =~ /newcamd525/i || $url2 =~ /mgcamd525/i)
	{
		$only_hosts=1;
		$url2 =~ s/newcamd525/http/i;
		$url2 =~ s/mgcamd525/http/i;
	}
	my $url1=new URI($url2);
	my $scheme=$url1->scheme();
	if($scheme !~ /http/ && $scheme !~ /https/)
	{
		$logger->warn("bad scheme for: $url2. Skip it.");
		next;
	}
	my $host=$url1->host();
	my $path=$url1->path();
	my $query=$url1->query();
	my $port=$url1->port();
	if($only_hosts)
	{
		my @url_ips=get_ips_for_record_id($ips->{record_id});
		foreach my $ip (@url_ips)
		{
			print $HOSTS_FILE "$ip:$port\n";
		}
		next;
	}
	if($scheme eq 'https')
	{
		next if(defined $ssl_hosts{$host});
		$ssl_hosts{$host}=1;
		print $SSL_HOST_FILE "$host\n";
		if($port ne "443")
		{
			$logger->info("Need to add another port for ssl $port");
		}
		next;
	}
	if($port ne "80")
	{
		$logger->info("Need to add another port for http $port");
	}
	my $url11=$url1->canonical();
	$url11 =~ s/^http\:\/\///g;

	# убираем любое упоминание о фрагменте... оно не нужно
	$url11 =~ s/^(.*)\#(.*)$/$1/g;

	print $URLS_FILE "$url11\n";
}
$sth->finish();


$sth = $dbh->prepare("SELECT INET_NTOA(ip) as ip FROM zap2_ips");
$sth->execute;
while (my $ips = $sth->fetchrow_hashref())
{
	my $ip=$ips->{ip};
	next if(defined $ip_s{$ip});
	$ip_s{$ip}=1;
	print $NET_FILE " network $ip/32\n";
}
$sth->finish();


parse_our_blacklist($Config->{'APP.blacklist'} || "");

print $NET_FILE "!\nline vty\n!\n\n";

close $DOMAINS_FILE;
close $URLS_FILE;
close $NET_FILE;
close $SSL_HOST_FILE;
close $HOSTS_FILE;

my $domains_file_hash=get_md5_sum($domains_file);
my $urls_file_hash=get_md5_sum($urls_file);
my $ssl_host_file_hash=get_md5_sum($ssls_file);
my $net_file_hash=get_md5_sum($bgpd_file);

if($net_file_hash ne $net_file_hash_old)
{
	$logger->debug("Restarting bgpd...");
	system("/bin/systemctl", "restart","bgpd");
	if ( $? == -1 )
	{
		$logger->error("Bgpd restart failed: $!");
	} else {
		$logger->info("Bgpd successfully restarted!");
	}
}
if($domains_file_hash ne $domains_file_hash_old || $urls_file_hash ne $urls_file_hash_old || $ssl_host_file_hash ne $ssl_host_file_hash_old)
{
	$logger->debug("Restarting nfqfilter...");
	system("/bin/systemctl", "restart","nfqfilter");
	if ( $? == -1 )
	{
		$logger->error("Nfqfilter restart failed: $!");
	} else {
		$logger->info("Nfqfilter successfully restarted!");
	}
}

$dbh->disconnect();

sub parse_our_blacklist
{
	my $file=shift;
	my @urls;
	if(open (my $our_f,"<",$file))
	{
		while(my $line=<$our_f>)
		{
			chomp $line;
			push(@urls,$line);
		}
		close($our_f);
	} else {
		warn "Could not open file '$file' $!";
		return ;
	}
	foreach my $url (@urls)
	{
		my $url1=new URI($url);
		my $scheme=$url1->scheme();
		if($scheme !~ /http/ && $scheme !~ /https/)
		{
			$logger->warn("bad scheme for: $url. Skip it.");
			next;
		}
		my $host=$url1->host();
		my $path=$url1->path();
		my $query=$url1->query();
		my $port=$url1->port();
		my @adrs = ();
		eval
		{
			@adrs = nslookup(domain => $host, server => @resolvers, timeout => 4 );
		};
		foreach my $ip (@adrs)
		{
			next if(defined $ip_s{$ip});
			$ip_s{$ip}=1;
			print $NET_FILE " network $ip/32\n";
		}
		if($scheme eq 'https')
		{
			next if(defined $ssl_hosts{$host});
			$ssl_hosts{$host}=1;
			print $SSL_HOST_FILE "$host\n";
			if($port ne "443")
			{
				$logger->info("Need to add another port for ssl $port");
			}
			next;
		}
		if($port ne "80")
		{
			$logger->info("Need to add another port for http $port");
		}
		my $url11=$url1->canonical();
		$url11 =~ s/^http\:\/\///g;
		print $URLS_FILE "$url11\n";
	}
}

sub get_md5_sum
{
	my $file=shift;
	open(my $MFILE, $file) or die "Can't open '$file': $!";
	binmode($MFILE);
	my $hash=Digest::MD5->new->addfile(*$MFILE)->hexdigest;
	close($MFILE);
	return $hash;
}

sub get_ips_for_record_id
{
	my $record_id=shift;
	my @ips;
	my $sth = $dbh->prepare("SELECT INET_NTOA(ip) as ip FROM zap2_ips WHERE record_id=$record_id");
	$sth->execute;
	while (my $ips = $sth->fetchrow_hashref())
	{
		push(@ips,$ips->{ip});
	}
	$sth->finish();
	return @ips;
}
